#include "mbed.h"

#define WAIT_TIME_MS 100

// Instantiate a Serial object for communicating with the serial monitor
BufferedSerial pc(USBTX, USBRX, 115200);

// Washing machine states
enum MachineState {
    STATE_OFF,
    STATE_ON,
    STATE_WASHING,
    STATE_PAUSED
};

MachineState currentState = STATE_OFF;

//Modes Meter
AnalogIn potentiometer(PA_7);

//MultiLED
PwmOut redled(PB_3); //define PWM pins for RGB LED
PwmOut greenled(PB_5);
PwmOut blueled(PB_4);

//buttons from left to right
DigitalIn button1(PC_10);
DigitalIn button2(PC_11);
DigitalIn button3(PD_2);

//Buzzer speaker
PwmOut buzzer(PA_15);

//7-segment display:

//segment       A       B     C      D    E     F      G        
BusOut SegDis(PA_11,PA_12,PB_1,PB_15,PB_14,PB_12,PB_11);
DigitalOut decimal_point(PB_2);

int main() {
    timer.start();
    bool finished_indicator = false;
    while (1) {
        float potValue = potentiometer.read(); // read potentiometer value

        // Button press and state update
        if (button1.read() == 1) {
            if (currentState == STATE_OFF) {
                currentState = STATE_ON;
            } else {
                currentState = STATE_OFF;
            }
            ThisThread::sleep_for(500ms); // Debounce the button press
        } else if (currentState != STATE_OFF && button2.read() == 1) {
            if (currentState == STATE_WASHING) {
                currentState = STATE_PAUSED;
            } else if (currentState == STATE_PAUSED) {
                currentState = STATE_WASHING;
            }
            ThisThread::sleep_for(500ms); // Debounce the button press
        } else if (currentState == STATE_ON && button3.read() == 1) {
            currentState = STATE_WASHING;
            ThisThread::sleep_for(500ms); // Debounce the button press
        }

        // RGB LED control and timer logic
        switch (currentState) {
            case STATE_OFF:
                redled.write(0.0);
                greenled.write(0.0);
                blueled.write(0.0);
                break;
            case STATE_ON:
                redled.write(1.0);
                greenled.write(0.0);
                blueled.write(0.0);
                break;
            case STATE_WASHING:
                redled.write(0.0);
                greenled.write(1.0);
                blueled.write(0.0);
                if (timer.elapsed_time().count() >= 1000000) {
                    remaining_time -= 1;
                    timer.reset();
                }
                if (remaining_time <= 0) {
                    currentState = STATE_FINISHED;
                }
                break;
            case STATE_PAUSED:
                redled.write(1.0);
                greenled.write(1.0);
                blueled.write(0.0);
                timer.reset();
                break;
            case STATE_FINISHED:
                if (!finished_indicator) {
                    for (int i = 0; i < 5; i++) {
                        redled.write(0.0);
                        greenled.write(1.0);
                        blueled.write(0.0);
                        ThisThread::sleep_for(200ms);
                        greenled.write(0.0);
                        ThisThread::sleep_for(200ms);
                    }
                    redled.write(1.0);
                    finished_indicator = true;
                    // Turn off the displays after the green LED flashes and becomes red
                    SegDis1.write(0x00);
                    SegDis2.write(0x00);
                }
                break;
        }

        // Display control
        if (currentState == STATE_ON && redled.read() == 1.0) {
            if (potValue < 0.33) {
                SegDis2.write(0x06);
            } else if (potValue >= 0.33 && potValue < 0.66) {
                SegDis2.write(0x5B);
            } else {
                SegDis2.write(0x4f);
            }
        } else if (currentState == STATE_WASHING || currentState == STATE_PAUSED) {
            updateDisplay(remaining_time);
        } else if (currentState != STATE_FINISHED) {
            SegDis2.write(0x00); // Turn off the display when the red light is off or in other
            } else if (currentState != STATE_FINISHED) {
            SegDis2.write(0x00); // Turn off the display when the red light is off or in other conditions
        }

        ThisThread::sleep_for(10ms);
    }
}
}
